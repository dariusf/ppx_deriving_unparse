type expr =
  | Num of int [@form _1]
  | Plus of expr * expr [@form _1 "+" _2][@prec (left, 3)]
  | Times of expr * expr [@form _1 "*" _2][@prec (left, 4)][@@deriving
                                                             unparse
                                                               {
                                                                 padding =
                                                                   " "
                                                               }]
include
  struct
    let _ = fun (_ : expr) -> ()
    let table_expr =
      function
      | Plus _ -> Some (3, (`Infix `Left))
      | Times _ -> Some (4, (`Infix `Left))
      | _ -> None
    let _ = table_expr
    let rec unparse_expr e =
      match e with
      | Num v0 -> string_of_int v0
      | Plus (v0, v1) ->
          String.concat " "
            [if Deriving_unparse.noparens table_expr v0 e 0
             then unparse_expr v0
             else Format.sprintf "(%s)" (unparse_expr v0);
            "+";
            if Deriving_unparse.noparens table_expr v1 e 1
            then unparse_expr v1
            else Format.sprintf "(%s)" (unparse_expr v1)]
      | Times (v0, v1) ->
          String.concat " "
            [if Deriving_unparse.noparens table_expr v0 e 0
             then unparse_expr v0
             else Format.sprintf "(%s)" (unparse_expr v0);
            "*";
            if Deriving_unparse.noparens table_expr v1 e 1
            then unparse_expr v1
            else Format.sprintf "(%s)" (unparse_expr v1)]
    let _ = unparse_expr
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
let () =
  let ex1 = Times ((Plus ((Num 1), (Num 2))), (Num 3)) in
  print_endline (unparse_expr ex1)
type protocol =
  | Comm of string * string [@form _1 "->" _2]
  | Par of protocol * protocol [@form _1 " || " _2][@prec (left, 3)]
  | Seq of protocol * protocol [@form _1 "; " _2][@prec (left, 4)][@@deriving
                                                                    unparse]
include
  struct
    let _ = fun (_ : protocol) -> ()
    let table_protocol =
      function
      | Par _ -> Some (3, (`Infix `Left))
      | Seq _ -> Some (4, (`Infix `Left))
      | _ -> None
    let _ = table_protocol
    let rec unparse_protocol e =
      match e with
      | Comm (v0, v1) -> String.concat "" [Fun.id v0; "->"; Fun.id v1]
      | Par (v0, v1) ->
          String.concat ""
            [if Deriving_unparse.noparens table_protocol v0 e 0
             then unparse_protocol v0
             else Format.sprintf "(%s)" (unparse_protocol v0);
            " || ";
            if Deriving_unparse.noparens table_protocol v1 e 1
            then unparse_protocol v1
            else Format.sprintf "(%s)" (unparse_protocol v1)]
      | Seq (v0, v1) ->
          String.concat ""
            [if Deriving_unparse.noparens table_protocol v0 e 0
             then unparse_protocol v0
             else Format.sprintf "(%s)" (unparse_protocol v0);
            "; ";
            if Deriving_unparse.noparens table_protocol v1 e 1
            then unparse_protocol v1
            else Format.sprintf "(%s)" (unparse_protocol v1)]
    let _ = unparse_protocol
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
let () =
  let ex1 =
    Seq ((Comm ("a", "b")), (Par ((Comm ("c", "d")), (Comm ("a", "b"))))) in
  print_endline (unparse_protocol ex1)
