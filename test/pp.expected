type expr =
  | Lit of int [@form _1]
  | Plus of expr * expr [@form _1 "+" _2][@prec (left, 3)]
  | Times of expr * expr [@form _1 "*" _2][@prec (left, 4)][@@deriving
                                                             unparse]
include
  struct
    let _ = fun (_ : expr) -> ()
    let table_expr =
      function
      | Plus _ -> Some (3, (`Infix `Left))
      | Times _ -> Some (4, (`Infix `Left))
      | _ -> None
    let _ = table_expr
    let rec render_expr e =
      match e with
      | Lit v0 -> string_of_int v0
      | Plus (v0, v1) ->
          String.concat " "
            [if Deriving_unparse.noparens table_expr v0 e 0
             then render_expr v0
             else Format.sprintf "(%s)" (render_expr v0);
            "+";
            if Deriving_unparse.noparens table_expr v1 e 1
            then render_expr v1
            else Format.sprintf "(%s)" (render_expr v1)]
      | Times (v0, v1) ->
          String.concat " "
            [if Deriving_unparse.noparens table_expr v0 e 0
             then render_expr v0
             else Format.sprintf "(%s)" (render_expr v0);
            "*";
            if Deriving_unparse.noparens table_expr v1 e 1
            then render_expr v1
            else Format.sprintf "(%s)" (render_expr v1)]
    let _ = render_expr
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
let ex1 = Times ((Plus ((Lit 1), (Lit 2))), (Lit 3))
let () = print_endline (render_expr ex1)
